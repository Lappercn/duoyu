import { defineStore } from 'pinia'
import api from '../services/api'
import audioService from '../services/audioService'

export const useAnalysisStore = defineStore('analysis', {
  state: () => ({
    currentAnalysisId: null,
    status: 'idle', // idle, processing, completed, failed
    consultantOutput: null,
    finalResult: null,
    debateTranscript: [], // Raw data from backend
    debatePlan: [], // List of topics generated by Host
    
    // State for User Interaction
    waitingForUser: false, // If true, show "I Understand" button
    userConfirmed: false, // User clicked "I Understand"
    
    // Presentation State
    visibleTranscript: [], 
    revealedTranscript: [], // Transcript items that have been played/revealed
    processedTranscriptIndex: 0, // Tracks how many items from backend have been pushed to queue
    activeSpeaker: null,   
    playbackQueue: [],     
    isPlaying: false,
    currentTopic: null, // Current topic being discussed
    showVerdictModal: false, // Controls visibility of verdict overlay      
  }),
  actions: {
    async startAnalysis(stockCode, riskProfile, marketSentiment) {
      this.status = 'processing'
      this.debateTranscript = []
      this.visibleTranscript = []
      this.revealedTranscript = []
      this.processedTranscriptIndex = 0
      this.playbackQueue = []
      this.consultantOutput = null
      this.finalResult = null
      this.activeSpeaker = 'consultant'
      this.isPlaying = false
      this.waitingForUser = false
      this.userConfirmed = false
      this.showVerdictModal = false
      
      // Reset intro flags
      this.introPlayed = {
          consultant: false,
          consultantGen: false,
          bull: false,
          bear: false,
          host: false
      }
      
      // 1. Consultant Intro
      this.playbackQueue.push({
          type: 'intro',
          speaker: 'consultant',
          content: '您好，我是您的首席情报官。正在为您扫描全网财经数据，请稍候。'
      });
      audioService.speak("您好，我是您的首席情报官。正在为您扫描全网财经数据，请稍候。", 'consultant');
      this.processQueue();

      try {
        const response = await api.startAnalysis({
          stockCode,
          riskProfile,
          marketSentiment
        })
        this.currentAnalysisId = response.data.data.analysisId
        this.pollStatus()
      } catch (error) {
        console.error(error)
        this.status = 'failed'
      }
    },

    confirmConsultant() {
        this.waitingForUser = false;
        this.userConfirmed = true;
        // Resume queue processing if there are items
        this.processQueue();
    },

    processQueue() {
        if (this.isPlaying || this.playbackQueue.length === 0) return;
        
        // Check for interaction block
        const nextItem = this.playbackQueue[0];
        if (nextItem.type === 'interaction') {
            if (!this.userConfirmed) {
                this.waitingForUser = true;
                return; // Stop processing until confirmed
            } else {
                // Remove interaction item and continue
                this.playbackQueue.shift();
                this.processQueue();
                return;
            }
        }

        this.playbackQueue.shift(); // Dequeue normal item
        this.isPlaying = true;
        this.activeSpeaker = nextItem.speaker;
        
        // Add to revealed transcript for UI timeline (SKIP for intro announcements)
        if (nextItem.type !== 'intro_announcement') {
            this.revealedTranscript.push({
                speaker: nextItem.speaker,
                content: nextItem.content,
                type: nextItem.type,
                timestamp: new Date()
            });
        }

        // Handle Consultant (No TTS)
        if (nextItem.speaker === 'consultant') {
            // Estimate reading time: 50ms per char, min 2s, max 5s
            const delay = Math.min(Math.max(nextItem.content.length * 50, 2000), 5000);
            
            setTimeout(() => {
                this.isPlaying = false;
                // Short pause before next
                setTimeout(() => {
                    this.processQueue();
                }, 500); 
            }, delay);
            return;
        }

        // Handle Intro Announcements (Audio Only, No Transcript)
        if (nextItem.type === 'intro_announcement') {
            audioService.speak(
                nextItem.content,
                nextItem.speaker,
                () => {},
                () => {
                    this.isPlaying = false;
                    setTimeout(() => {
                        this.processQueue();
                    }, 500);
                }
            );
            return;
        }

        // Handle Debate Roles (TTS with Delays)
        // Pre-speech delay
        setTimeout(() => {
            audioService.speak(
                nextItem.content, 
                nextItem.speaker,
                () => { /* onStart */ },
                () => { 
                    // Post-speech delay
                    this.isPlaying = false;
                    
                    // Check if this was the final summary to trigger verdict
                    if (nextItem.type === 'final_summary') {
                        this.showVerdictModal = true;
                    }

                    setTimeout(() => {
                        this.processQueue();
                    }, 1500); // 1.5s delay between speakers
                }
            );
        }, 500); // 0.5s delay before speaking
    },

    async pollStatus() {
      if (!this.currentAnalysisId) return

      const interval = setInterval(async () => {
        try {
          const response = await api.getAnalysisStatus(this.currentAnalysisId)
          const data = response.data.data
          
          this.status = data.status
          
          // Update Data
          if (data.consultantOutput) this.consultantOutput = data.consultantOutput
          if (data.debatePlan) this.debatePlan = data.debatePlan
          
          // 2. Consultant Generating Check
          if (this.consultantOutput && this.consultantOutput.marketInfoSummary && !this.introPlayed.consultantGen) {
              // Wait until we have a reasonable amount of text
              if (this.consultantOutput.marketInfoSummary.length > 50) {
                  this.introPlayed.consultantGen = true;
                  this.playbackQueue.push({
                      type: 'status',
                      speaker: 'consultant',
                      content: '情报收集完毕，正在生成核心分析报告。'
                  });
                  
                  // Add Interaction Point after report is ready
                  this.playbackQueue.push({
                      type: 'interaction',
                      speaker: 'consultant'
                  });
                  
                  this.processQueue();
              }
          }

          // 3. Debate Logic (Only process if user confirmed)
          if (this.userConfirmed && data.debateTranscript) {
              this.visibleTranscript = data.debateTranscript; // Keep raw sync for reference if needed
              
              // Process new items from backend
              if (data.debateTranscript.length > this.processedTranscriptIndex) {
                  const newItems = data.debateTranscript.slice(this.processedTranscriptIndex);
                  let itemsProcessedCount = 0;
                  
                  for (const item of newItems) {
                      // If content is empty, we stop processing and wait for next poll
                      // This ensures we don't skip items that are currently being initialized by backend
                      if (!item.content || item.content.trim().length === 0) {
                          break;
                      }
                      
                      // Wait until content is substantial (e.g., > 5 chars) to avoid partial reads
                      // Unless it's marked as completed by some flag (which we don't have yet), 
                      // but typically streaming sends small chunks. 
                      // However, the issue "Only reading two words" suggests we are queuing it too early 
                      // while it's still streaming.
                      // But the orchestrator updates the DB in chunks. 
                      // If we queue it now, the 'content' in the queue object is a snapshot string.
                      // It won't update as the DB updates.
                      // FIX: We need to queue a reference or handle updates.
                      // Actually, for TTS, we need the FULL sentence.
                      // So we should only queue it when we are sure it's mostly done or process it differently.
                      
                      // Since we don't have a "done" flag per message in the schema yet,
                      // we can check if the *next* message exists. 
                      // If message N+1 exists, then message N is definitely done.
                      // For the very last message, we might need to wait or rely on status.
                      
                      // Let's verify if this item is "safe" to queue.
                      // Logic: Can only queue item `i` if item `i+1` exists OR if status is 'completed'.
                      const itemIndex = data.debateTranscript.indexOf(item);
                      const isLastItem = itemIndex === data.debateTranscript.length - 1;
                      
                      if (isLastItem && data.status !== 'completed') {
                          // It's the last item and analysis is still running -> likely still streaming.
                          // Don't queue it yet.
                          break;
                      }
                      
                      // Determine type
                      let type = 'debate_turn';
                      if (item.round === 99) type = 'final_summary'; // Host summary
                      
                      this.playbackQueue.push({
                          type: type,
                          speaker: item.speaker,
                          content: item.content, // This is now the full content
                          topic: item.topic
                      });
                      
                      // If it's a new topic, update current topic
                      if (item.topic) {
                          this.currentTopic = item.topic;
                      }
                      
                      itemsProcessedCount++;
                  }
                  
                  // Only advance the index by the number of items we successfully processed
                  this.processedTranscriptIndex += itemsProcessedCount;
                  
                  if (itemsProcessedCount > 0) {
                      this.processQueue();
                  }
              }
              
              // Bull Entrance
              const bullLog = this.visibleTranscript.find(l => l.speaker === 'bull');
              if (bullLog && !this.introPlayed.bull) {
                  this.introPlayed.bull = true;
                  // No hardcoded intro, handled by backend content
                  this.playbackQueue.unshift({
                      type: 'intro_announcement',
                      speaker: 'bull',
                      content: "机会挖掘官已上线。"
                  });
                  this.processQueue();
              }

              // Bear Entrance
              const bearLog = this.visibleTranscript.find(l => l.speaker === 'bear');
              if (bearLog && !this.introPlayed.bear) {
                  this.introPlayed.bear = true;
                  // No hardcoded intro, handled by backend content
                  this.playbackQueue.unshift({
                      type: 'intro_announcement',
                      speaker: 'bear',
                      content: "风险预警官已上线。"
                  });
                  this.processQueue();
              }
              
          }
      
          // Final Result
          if (data.finalResult) {
              this.finalResult = data.finalResult
          }
          
          if (this.status === 'completed' || this.status === 'failed') {
             clearInterval(interval)
          }
        } catch (error) {
          console.error(error)
          clearInterval(interval)
          this.status = 'failed'
        }
      }, 1000)
    }
  }
})

